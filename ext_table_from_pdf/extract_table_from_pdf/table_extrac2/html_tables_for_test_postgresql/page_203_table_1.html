<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM</td>
    </tr>
    <tr>
      <td>Tuesday evening, and are up and running. In this history of the database universe, you never dropped the</td>
    </tr>
    <tr>
      <td>table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime</td>
    </tr>
    <tr>
      <td>Wednesday morning in the original history. You won't be able to if, while your database was up-and-</td>
    </tr>
    <tr>
      <td>running, it overwrote some of the WAL segment files that led up to the time you now wish you could get</td>
    </tr>
    <tr>
      <td>back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done</td>
    </tr>
    <tr>
      <td>a point-in-time recovery from those that were generated in the original database history.</td>
    </tr>
    <tr>
      <td>To deal with this problem, PostgreSQL has a notion of timelines. Whenever an archive recovery completes,</td>
    </tr>
    <tr>
      <td>a new timeline is created to identify the series of WAL records generated after that recovery. The timeline</td>
    </tr>
    <tr>
      <td>ID number is part of WAL segment file names so a new timeline does not overwrite the WAL data gen-</td>
    </tr>
    <tr>
      <td>erated by previous timelines. It is in fact possible to archive many different timelines. While that might</td>
    </tr>
    <tr>
      <td>seem like a useless feature, it's often a lifesaver. Consider the situation where you aren't quite sure what</td>
    </tr>
    <tr>
      <td>point-in-time to recover to, and so have to do several point-in-time recoveries by trial and error until you</td>
    </tr>
  </tbody>
</table>