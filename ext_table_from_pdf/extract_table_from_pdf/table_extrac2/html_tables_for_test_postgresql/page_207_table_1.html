<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>the archive command for every WAL segment it receives, whether it's by restoring from the archive or</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>by streaming replication. The shared archive can be handled similarly, but the archive_command or</td>
    </tr>
    <tr>
      <td>archive_library must test if the file being archived exists already, and if the existing file has iden-</td>
    </tr>
    <tr>
      <td>tical contents. This requires more care in the archive_command or archive_library, as it must</td>
    </tr>
    <tr>
      <td>be careful to not overwrite an existing file with different contents, but return success if the exactly same</td>
    </tr>
    <tr>
      <td>file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive</td>
    </tr>
    <tr>
      <td>the same file at the same time.</td>
    </tr>
    <tr>
      <td>If archive_mode is set to on, the archiver is not enabled during recovery or standby mode. If the standby</td>
    </tr>
    <tr>
      <td>server is promoted, it will start archiving after the promotion, but will not archive any WAL or timeline</td>
    </tr>
    <tr>
      <td>history files that it did not generate itself. To get a complete series of WAL files in the archive, you must</td>
    </tr>
    <tr>
      <td>ensure that all WAL is archived, before it reaches the standby. This is inherently true with file-based log</td>
    </tr>
  </tbody>
</table>