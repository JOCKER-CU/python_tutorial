<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>the second example, a simple SELECT from one view created a final query tree that is a join of 4 tables</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(unit was used twice with different names).</td>
    </tr>
    <tr>
      <td>The benefit of implementing views with the rule system is that the planner has all the information about</td>
    </tr>
    <tr>
      <td>which tables have to be scanned plus the relationships between these tables plus the restrictive qualifica-</td>
    </tr>
    <tr>
      <td>tions from the views plus the qualifications from the original query in one single query tree. And this is</td>
    </tr>
    <tr>
      <td>still the situation when the original query is already a join over views. The planner has to decide which</td>
    </tr>
    <tr>
      <td>is the best path to execute the query, and the more information the planner has, the better this decision</td>
    </tr>
    <tr>
      <td>can be. And the rule system as implemented in PostgreSQL ensures that this is all information available</td>
    </tr>
    <tr>
      <td>about the query up to that point.</td>
    </tr>
    <tr>
      <td>. Updating a View</td>
    </tr>
    <tr>
      <td>What happens if a view is named as the target relation for an INSERT, UPDATE, or DELETE? Doing the</td>
    </tr>
    <tr>
      <td>substitutions described above would give a query tree in which the result relation points at a subquery</td>
    </tr>
  </tbody>
</table>